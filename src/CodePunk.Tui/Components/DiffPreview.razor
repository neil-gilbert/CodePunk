@namespace CodePunk.Tui.Components

@using Spectre.Console
@using RazorConsole.Components
@using CodePunk.Core.SyntaxHighlighting.Abstractions
@using CodePunk.Core.SyntaxHighlighting
@using CodePunk.Core.SyntaxHighlighting.Tokenization
@using System.Linq

@code {
    [Parameter]
    public string? Diff { get; set; }

    [Parameter]
    public int MaxLines { get; set; } = 200;

    [Parameter]
    public string? Path { get; set; }

    [Inject]
    private ISyntaxHighlighter? Syntax { get; set; }

    private string _lastRenderKey = string.Empty;
    private bool _shouldRender = true;

    protected override void OnParametersSet()
    {
        var key = $"{Path}|{Diff?.GetHashCode()}|{MaxLines}";
        _shouldRender = !string.Equals(key, _lastRenderKey, StringComparison.Ordinal);
        if (_shouldRender) _lastRenderKey = key;
    }

    protected override bool ShouldRender() => _shouldRender;

    // Current simplified styling: black background, white text
    private static readonly Color LineBackground = Color.Grey0; // black
    private static readonly Color LineForeground = Color.White;

    // For now we render code as a single run (token highlighting removed to stabilize layout)
    private string GetCodeText(string content) => content ?? string.Empty;

    private enum DiffLineType { Context, Addition, Deletion }
    private sealed record DiffLine(DiffLineType Type, string Content, int OldLineNum, int NewLineNum);
    private sealed record DiffSection(int OldStartLine, int NewStartLine, List<DiffLine> Lines);

    private static List<DiffSection> ParseDiffIntoSections(string diff)
    {
        var lines = diff.Split('\n');
        var sections = new List<DiffSection>();
        var hunk = new System.Text.RegularExpressions.Regex(@"^@@ -(\d+),\d+ \+(\d+),\d+ @@");
        DiffSection? current = null;
        int oldLine = 0, newLine = 0;

        foreach (var line in lines)
        {
            if (line.StartsWith("@@"))
            {
                if (current != null) sections.Add(current);
                var m = hunk.Match(line);
                if (m.Success)
                {
                    oldLine = int.Parse(m.Groups[1].Value);
                    newLine = int.Parse(m.Groups[2].Value);
                    current = new DiffSection(oldLine, newLine, new List<DiffLine>());
                }
            }
            else if (current != null && !line.StartsWith("---") && !line.StartsWith("+++"))
            {
                if (line.StartsWith("+"))
                {
                    var body = line.Length > 1 ? line[1..] : string.Empty;
                    current.Lines.Add(new DiffLine(DiffLineType.Addition, body, -1, newLine));
                    newLine++;
                }
                else if (line.StartsWith("-"))
                {
                    var body = line.Length > 1 ? line[1..] : string.Empty;
                    current.Lines.Add(new DiffLine(DiffLineType.Deletion, body, oldLine, -1));
                    oldLine++;
                }
                else
                {
                    var body = line.StartsWith(" ") ? (line.Length > 1 ? line[1..] : string.Empty) : line;
                    current.Lines.Add(new DiffLine(DiffLineType.Context, body, oldLine, newLine));
                    oldLine++; newLine++;
                }
            }
        }

        if (current != null) sections.Add(current);
        return sections;
    }

    private static List<DiffSection> MergeAdjacentSections(List<DiffSection> sections)
    {
        if (sections.Count <= 1) return sections;
        var allLines = new List<DiffLine>();
        var seen = new HashSet<(int oldLine, int newLine, string content, DiffLineType type)>();
        int minOld = sections.Min(s => s.OldStartLine);
        int minNew = sections.Min(s => s.NewStartLine);

        foreach (var s in sections.OrderBy(s => s.OldStartLine))
        {
            foreach (var l in s.Lines)
            {
                var key = (l.OldLineNum, l.NewLineNum, l.Content, l.Type);
                if (seen.Add(key)) allLines.Add(l);
            }
        }

        allLines = allLines.OrderBy(l =>
        {
            if (l.Type == DiffLineType.Context || l.Type == DiffLineType.Deletion)
                return l.OldLineNum != -1 ? l.OldLineNum : int.MaxValue;
            return l.NewLineNum != -1 ? l.NewLineNum : int.MaxValue;
        }).ToList();

        return new List<DiffSection> { new DiffSection(minOld, minNew, allLines) };
    }

    private static List<DiffLine> GetLinesWithContext(List<DiffLine> lines, int context)
    {
        var result = new List<DiffLine>();
        var changed = new HashSet<int>();
        for (int i = 0; i < lines.Count; i++) if (lines[i].Type != DiffLineType.Context) changed.Add(i);
        var include = new HashSet<int>();
        foreach (var idx in changed)
        {
            for (int i = Math.Max(0, idx - context); i <= Math.Min(lines.Count - 1, idx + context); i++) include.Add(i);
        }
        foreach (var i in include.OrderBy(x => x)) result.Add(lines[i]);
        return result;
    }

    private static Color MapFgForLine(DiffLineType type) => LineForeground;

    private RenderFragment RenderUnifiedView() => builder =>
    {
        if (string.IsNullOrEmpty(Diff)) return;

        var sections = MergeAdjacentSections(ParseDiffIntoSections(Diff!));
        var section = sections.FirstOrDefault();
        if (section == null) return;

        var filtered = GetLinesWithContext(section.Lines, 2);
        if (filtered.Count == 0) return;

        const int maxLinesTotal = 25;
        if (filtered.Count > maxLinesTotal)
        {
            var changes = filtered.Count(l => l.Type != DiffLineType.Context);
            builder.OpenComponent<RazorConsole.Components.Markup>(0);
            builder.AddAttribute(1, "Content", $"Showing first {maxLinesTotal} lines ({changes} total changes)");
            builder.AddAttribute(2, "Foreground", Color.Grey62);
            builder.AddAttribute(3, "Decoration", Decoration.Dim);
            builder.CloseComponent();
            filtered = filtered.Take(maxLinesTotal).ToList();
        }

        static string FormatLineNumberText(int lineNumber) => lineNumber >= 0 ? lineNumber.ToString().PadLeft(3) : "   ";

        int seq = 10;
        // Use shared formatter so tests can validate output
        var displayLines = CodePunk.Tui.Rendering.DiffLineFormatter.BuildDisplayLines(Diff!, 2, maxLinesTotal);
        foreach (var text in displayLines)
        {
            builder.OpenComponent<RazorConsole.Components.Markup>(seq++);
            builder.AddAttribute(seq++, "Content", Spectre.Console.Markup.Escape(text));
            builder.AddAttribute(seq++, "Foreground", LineForeground);
            builder.AddAttribute(seq++, "Background", LineBackground);
            builder.CloseComponent();
        }
    };
}

@RenderUnifiedView()
